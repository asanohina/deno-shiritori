<!DOCTYPE html>
<html lang="ja">

<head>
  <!-- headタグの中にはメタデータ等を記載する -->
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>しりとりゲーム</title>
  <link rel="stylesheet" href="styles.css">
  <style>
    .container {
      display: flex;
      /* フレックスボックスを使用*/
      justify-content: space-between;
      /* 子要素を左右に配置 */
      padding: 20px;
      /* パディングを追加 */
    }

    .game,
    .rules {
      width: 48%;
      /* 各要素の幅を指定*/
    }

    .rules {
      border-left: 2px solid #ccc;
      /* 左側に境界線を追加 */
      padding-left: 20px;
      /* 左側のパディングを追加 */
    }

    li {
      margin-bottom: 4px;
      /* 各リストアイテムの下にスペースを追加 */
    }
  </style>
</head>

<!-- bodyタグの中には実際に表示するものなどを書く -->

<body>
  <!-- モード選択ページ -->
  <div id="modePage">
    <h1 style="text-align:center;">しりとりゲーム</h1>
    <h2 style="text-align:center;">モードを選択してください</h2>
    <div align="center">
      <button onclick="selectMode('normal')">ノーマルモード</button>
    </div>
    <div align="center">
      <button onclick="selectMode('limited')"> 時間制限モード </button>
    </div>
  </div>

  <!-- ゲームページ -->
  <!-- style="display:none;・・・「最初は表示されない」 -->
  <div id="gamePage" style="display: none;">

    <!--
      <div class = "container">
        <div class = "game">しりとり</div>
        <div class = "rules">ルール</div>
      </div>
      しりとり画面 | ルール説明
      のように横並びにレイアウトする 
    -->


    <!-- 
      「h1」は見出しのタグで、一番大きい見出し
      「h2」は二番目に大きい見出し
      「p」はparagraph（段落）
      id属性は、HTML要素に一意の識別子を与えるための属性
      idは1ページ内で一回しか使用できない、「固有の名前」をつけるための属性
      「input」はユーザーが入力できるフィールド
      「button」はボタンを作成するためのタグ
      「ul」はunordered list（順不同リスト）を作成するためのタグ
      「li」はlist item（リストアイテム）を作成するためのタグ
    -->

    <div class="container">
      <!-- 左側：ゲーム -->
      <div class="game">
        <!-- タイトル -->
        <h1>しりとり</h1>
        <!-- 現在の単語を表示する場所 -->
        <p id="previousWord"></p>
        <!-- 次の文字を入力するフォーム -->
        <input id="nextWordInput" type="text" placeholder="次の単語を入力" />
        <!-- 送信ボタン、リセットボタン -->
        <button id="nextWordSendButton">送信</button>
        <button id="resetButton">リセット</button>

        <p id="timerDisplay" style="color:red; font-weight:bold;"></p>

        <h2>しりとり履歴</h2>
        <p id="recordText" style="color: red; font-weight: bold;"></p>
        <!-- 履歴を表示 -->
        <ul id="historyList"></ul>
      </div>

      <!-- 右側：ルール -->
      <div class="rules">
        <h2>ルール</h2>
        <ul>
          <li id="limitedRule" style="color:red; display:none;">時間制限モードでは、10秒以内に次の単語を入力しなければいけません。</li>
          <li>最初の単語はランダムで設定されます。</li>
          <li>使った単語を再び使用することができません。</li>
          <li>「ん」で終わる単語は使用できません。</li>
          <li>半角カタカナ、全角カタカナは自動で平仮名に変換されます。</li>
          <li>小文字は大文字に変換されます</li>
          <ul>
            <li style="font-size:0.8em;"> 例.「ゃ」→「や」、「ぁ」→「あ」</li>
          </ul>
          <li>「ー」は直前の単語の母音と同じ扱いになります。</li>
          <ul>
            <li style="font-size:0.8em;"> 例.「コーヒー」→「ヒ」の母音の「い」</li>
          </ul>
          <li>リセットを押すことで、ゲームを再スタートすることができます。</li>
          </li>
        </ul>
      </div>
      <!-- ボタンの上側に20pxの余白を空ける -->
      <div style="margin-top: 20px;">
        <button onclick="backToMode()">モード選択に戻る</button>
      </div>
    </div>

    <!-- 外部のJavaScriptファイル（moji.js）を読み込むためのタグ -->
    <script src="/moji-master/dist/moji.js"></script>

    <!-- JavaScriptを実行 -->
    <script>
      let currentMode = "normal";  // 現在のモード
      let timeLimit = 10;          // 制限時間10秒
      let timerId = null;          // タイマーID
      let remainingTime = timeLimit;  // 残り時間


      function selectMode(mode) {  // 引数modeに"normal"または"limited"が入る
        currentMode = mode;
        // モード選択ページを非表示にし、ゲームページを表示
        document.getElementById("modePage").style.display = "none";
        document.getElementById("gamePage").style.display = "block";

        // 制限モードのルール文を表示・非表示切り替え
        // 条件式 ? 条件がtrueのときの値 : 条件がfalseのときの値
        document.getElementById("limitedRule").style.display = (mode === "limited") ? "list-item" : "none";

        if (mode === "limited") {
          startTimer();
        } else {
          // ノーマルモードの場合、タイマーを停止
          stopTimer();  // タイマーを停止する関数
          clearTimerDisplay();  // タイマーの表示を消す
        }
      }

      function startTimer() {
        stopTimer();  // 既存のタイマーを停止

        remainingTime = timeLimit;  // 残り時間をリセット
        updateTimerDisplay();  // タイマーの表示を更新

        timerId = setInterval(() => {
          remainingTime--;  // 残り時間を1秒減らす
          updateTimerDisplay();  // タイマーの表示を更新

          if (remainingTime <= 0) {
            stopTimer();  // タイマーを停止
            alert("時間切れです！次の単語を入力できませんでした。");
            document.querySelector("#nextWordInput").disabled = true;  // 入力フィールドを無効化
          }
        }, 1000);  // 1秒ごとに実行
      }

      function stopTimer() {
        if (timerId) {
          // clearInterval()は、setInterval()で設定したタイマーを停止するための関数
          clearInterval(timerId);  // タイマーを停止
          timerId = null;  // タイマーIDをリセット
        }
      }

      // タイマー表示を制御する関数（予測変換により実装）
      function updateTimerDisplay() {
        const timerDisplay = document.getElementById("timerDisplay");
        timerDisplay.textContent = `残り時間: ${remainingTime}秒`;
      }

      // タイマー表示を消す関数（予測変換により実装）
      function clearTimerDisplay() {
        const timerDisplay = document.getElementById("timerDisplay");
        timerDisplay.textContent = "";  // タイマー表示を空にする
      }

      // モード選択ページを表示する関数
      async function backToMode() {
        // サーバーにリセットを要求
        try {
          const response = await fetch("/reset", { method: "POST" });
          if (response.status !== 200) {
            alert("ゲーム状態のリセットに失敗しました。");
          }
        } catch (e) {
          console.error("リセットリクエストに失敗しました", e);
        }

        // ゲームページの要素をリセット
        document.querySelector("#previousWord").textContent = "";  // 前の単語をクリア
        document.querySelector("#nextWordInput").value = "";  // 入力フィールドをクリア
        document.querySelector("#nextWordInput").disabled = false;  // 入力フィールドを有効化
        document.querySelector("#nextWordSendButton").disabled = false; // 送信ボタンを有効化

        // モード選択ページを表示し、ゲームページを非表示
        document.getElementById("modePage").style.display = "block";
        document.getElementById("gamePage").style.display = "none";
        // 記録表示をクリア
        document.querySelector("#recordText").textContent = "";

        // 最新の単語をサーバーから取得する場合
        try {
          const response = await fetch("/shiritori");
          if (response.ok) {
            const result = await response.json();
            document.querySelector("#previousWord").innerHTML = `前の単語: ${result.lastWord}`;
          }
        } catch (e) {
          console.error("単語の取得に失敗しました", e);
        }
        await updateHistory();  // 履歴を更新する関数を呼び出す
      }

      // しりとりの履歴を取得し、表示する
      async function updateHistory() {

        //「/history」というURLにアクセスし、サーバーから履歴を取得
        // fetch()とは、指定したURLにHTTPリクエストを送信し、レスポンスを取得するための関数
        const response = await fetch("/history");

        // レスポンスのステータスが200（成功）の時の処理
        if (response.status === 200) {

          // awaitとは、非同期処理が完了するまで待機するためのキーワード
          const data = await response.json();

          // 履歴のテキストを更新
          /*
            HTMLの中にあるidが「 historyList の要素」を取得する

            document.querySelector()とは、特定の要素を探す関数
            「#historyList」=「<ul id="historyList"></ul>」　リスト要素を指す

          */
          const historyList = document.querySelector("#historyList");
          // innerHTMLはHTML要素の中身を読み書きするためのプロパティ
          // innerHTMLを空にして、既存のリストをクリア
          historyList.innerHTML = "";


          // data.historyは、サーバーから取得した履歴の配列
          // for...ofループを使って、その配列を先頭から1つずつ取り出す
          // 各単語がwordという変数に格納される

          // よって、historyList.innerHTML = "";でリストを空にしても値は正常に更新され続ける！
          for (const word of data.history) {
            const li = document.createElement("li");  // <li></li>を作成
            li.textContent = word;  // <li></li>の中にwordの中身を追加

            /* <ul id="historyList"></ul>の中に<li></li>を追加
              appendChild()は、指定した要素を親要素の最後に追加するためのメソッド
              <ul id="historyList">
                <li>りんご</li>
                <li>ごりら</li>
                <li>ラッパ</li>
              </ul>
            */
            historyList.appendChild(li);
          }
        }
      }

      // 送信ボタン押下時の処理
      async function sendWord() {
        const nextWordInput = document.querySelector("#nextWordInput");  // 入力フィールドを取得
        // .valueで入力フィールド（ユーザーが入力した文字列）の値を取得
        // .trim()で前後の空白を削除　「 りんご 」→「りんご」
        let nextWordInputText = nextWordInput.value.trim();

        if (!nextWordInputText) {
          alert("単語を入力してください。");
          return;
        }

        // mojiを使って半角カタカナと全角カタカナをひらがなに変換
        nextWordInputText = moji(nextWordInputText)
          .convert("HK", "HG")  // 半角カナ→ひらがな
          .convert("KK", "HG")  // 全角カナ→ひらがな
          .toString();


        // タイムアウトを設定するAbortsController
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 5000); // 5秒でタイムアウト

        // fetch()を使ってサーバーにリクエストを送信
        // 送信した単語を判定
        try {
          const response = await fetch("/shiritori", {
            method: "POST",           // POSTメソッドでリクエスト
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ nextWord: nextWordInputText }),
            signal: controller.signal // タイムアウトシグナルを渡す
          });

          clearTimeout(timeoutId);    // 成功したらタイムアウトをクリア

          if (response.status !== 200) {  // エラーの場合
            const errorJson = await response.json();  // サーバーから送られるエラーメッセージをJSON形式で取得
            alert(errorJson["errorMessage"]);
          } else {
            const result = await response.json();
            const paragraph = document.querySelector("#previousWord");  // 直前の単語を表示する段落要素を取得
            paragraph.innerHTML = `前の単語: ${result.previousWord}`;
            nextWordInput.value = "";  // 入力フィールドをクリア

            if (currentMode === "limited") {
              // 制限時間モードの場合、タイマーをリセットして再スタート
              startTimer();
            }

            // ゲーム―オーバー
            if (result.gameOver === true) {
              // ゲーム終了したらタイマー停止
              stopTimer();
              // ゲームオーバーの場合、入力フォームと送信ボタンを無効化
              document.querySelector("#nextWordInput").disabled = true;
              document.querySelector("#nextWordSendButton").disabled = true;
              // リセットボタンは残す
              alert(result.message);  // ゲームオーバーメッセージを表示

              // 記録表示
              const recordText = document.querySelector("#recordText");

              try {
                const historyResponse = await fetch("/history");
                const historyData = await historyResponse.json();
                const count = historyData.history.length - 1; // 配列の要素数を取得しcountに定数を代入　最初の単語は要素数から除外
                recordText.textContent = `記録は、${count}回です！`;
              } catch (e) {
                console.error("履歴の取得に失敗しました:", e);
                recordText.textContent = "記録を取得できませんでした。";
              }
            }
            await updateHistory();  // 履歴を更新
          }
        } catch (error) {
          clearTimeout(timeoutId);
          if (error.name === 'AbortError') {
            alert("リクエストがタイムアウトしました。ネットワーク接続を確認してください。");
          } else {
            alert(`通信エラーが発生しました: ${error.message}`);
          }
          console.error("Fetch error:", error);
        }
      }

      // しりとりアプリの初期化
      // ページが読み込まれたとき（ウィンドウのロード完了時）に実行される
      window.onload = async () => {
        const paragraph = document.querySelector("#previousWord");
        try {
          const response = await fetch("/shiritori", { method: "GET" });  // 今のしりとりの最新単語を取得する
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          const data = await response.json();
          const previousWord = data.lastWord;  // 帰ってきたJSONデータからlastword（最後の単語）を取得。
          paragraph.innerHTML = `前の単語: ${previousWord}`;

        } catch (error) {
          console.error("初期単語の取得に失敗しました:", error);
          paragraph.innerHTML = "初期単語の読み込みに失敗しました。"; // エラー表示
        }

        await updateHistory();
        document.querySelector("#nextWordSendButton").onclick = sendWord; // 送信ボタンのクリックされたときsendWord関数を実行する

        document.querySelector("#nextWordInput").onkeydown = function (event) {
          if (event.key === 'Enter') {
            sendWord();  // Enterキーが押されたときにsendWord関数を実行
          }
        }
      };

      // リセットボタンの押下時に実行
      document.querySelector("#resetButton").onclick = async (event) => {
        const response = await fetch(
          "/reset",
          {
            method: "POST",
          }
        );

        // status: 200以外が返ってきた場合にエラーを表示
        // リセットが成功した場合、「前の単語」を更新
        if (response.status === 200) {
          const result = await response.json();
          const paragraph = document.querySelector("#previousWord");
          paragraph.innerHTML = `前の単語: ${result.previousWord}`; // リセット後の初期単語を更新
          alert(result.message);

          await updateHistory();

          document.querySelector("#nextWordInput").disabled = false; // 入力フィールドを有効化
          document.querySelector("#nextWordSendButton").disabled = false; // 送信ボタンを有効化

          nextWordInput.value = "";  // 入力フィールドをクリア
          document.querySelector("#recordText").textContent = ""; // 記録表示をクリア

          if (currentMode === "limited") {
            startTimer();  // 制限時間モードの場合、タイマーを再スタート
          } else {
            stopTimer();  // ノーマルモードの場合、タイマーを停止
            clearTimerDisplay();  // タイマーの表示を消す
          }
        } else {
          alert("リセットに失敗しました。");
        }
      };
    </script>
  </div>

</body>

</html>